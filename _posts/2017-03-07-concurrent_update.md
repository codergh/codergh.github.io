---
layout: post
title: '并发更新数据的解决方案'
tags:
  - 并发
  - 数据更新
category: 
---
随着业务量的越来越大， 为了增加系统的负载量， 高并发是必须的。 如何保证高并发下数据的一致性就成为了一个重要问题
。
<!--more-->

# 问题背景： #
数据库中有一张表A， 里面有一个字段count， 有一个多线程的程序去递加这个字段。

# 有可能出现的问题 #
两个线程同时递加count， 递加的时候牵扯到select和update的问题， 后一个线程的递加更新可能会覆盖前一个线程的递加更新

# 解决方案 #
## 解决方案一 ##
把select语句和update语句合并成一个update语句， 例如：
```
update A set count=count+1;
```

## 解决方案二 ##
利用事务将select和update操作包裹在一起。
Mysql的InnoDb引擎下支持行锁， 包括读共享锁和写独占锁。

### 读共享锁可以通过下面的方式取得   ###
```
Select * from A lock in share mode;
```

如果线程B先获得了某条数据的读共享锁， 事务C仍然可以读取该条数据， 但是必须等待事务B的commit或者rollback之后才能对该条数据进行更新或者删除操作。


### 写独占锁 可以通过下面的方式取得  ###
```




select count from A for update;
update A set count = count1;
```

如果事务B获得了某行数据的写独占锁，事务C必须等事务Bcommit或者rollback之后才能访问该行数据

在这里肯定要使用写独占锁

## 解决方案三
乐观锁： 通过指定where条件来限制更新

```
update A set count = count1 where count = count2
```
根据更新结果来判断并发更新的成功与失败， 失败的话，重新来一次就行了

# 优劣比较 #

* 方案一利用比较负载的sql来解决问题， 在业务场景比较复杂的情况下，不建议使用，因为过于冗长的sql不利于维护， 而且性能也不好
* 方案二使用写独占锁， 能解决问题但是不常用
* 方案三在不使用事务的情况下能解决问题， 推荐使用





