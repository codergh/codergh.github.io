---
layout: post
title: '事务入门'
tags:
  - 事务
  -
category: 架构
---
数据库事务和spring事务是编程中很常见的东西， 所以今天系统的总结一下。

<!--more-->
## 使用事务的目的
保证数据的一致性

## 什么是事务
事务是应用程序中一些列严密的操作， 所有的操作必须成功， 否则每个操纵中所作的更改都会被撤销

## 事务的两个重要特性

* 数据的隔离级别
* 数据的传播级别

### 数据的隔离级别

* Serializable     : 最严格的级别，事务串行执行，资源消耗最大。
* Repeat Able Read : 保证了一个事务不会修改已经由另一个事务未读取但并未commit（未commit=回滚）的数据， 避免了脏读和不可重复读的情况， 但带来了更多的性能损失。
* Read committed:  : 保证了一个是不不会读取已经由另一个事务修改但并未commit的数据， 避免了脏读， 是大多数数据库的默认隔离级别。 该级别适用于大多数系统。
* Read uncommitted : 保证不会读取到非法数据。

下面解释一下几个特殊词语

* 脏读其实就是一个事务读取到了另一个并行事务回滚前修改的数据，比如A事务在执行过程中修改了数据X， A事务在B事务commit之前读取到A事务修改后的数据。
* 不可重复读： 就是2次读取的数据不一样， 例如A事务首先读取数据X， 然后在执行逻辑的时候， 事务B修改了数据X， 然后事务A又重新读取了数据X， 前后两次读取的数据不一样
* 幻读： 就是第二次读的时候比第一次读的时候读多了， 例如A事务开始读取了10条数据， 然后执行逻辑的时候， 事务B添加了一条数据，然后事务A再次读取的时候读取了11条数据。

所以最安全的还是Serializable隔离级别， 但是性能开销也最高。另外事务还有2个常用的属性readyonly和timeout。
readonly用来设置事务是只读事务， 用以提升性能。
timeout用来设置过期时间， 防止事务过大。

### 数据的传播级别

* propagation_required: 默认spring的事务传播级别，使用该级别的特点是， 如果上下文中已经存在事务，那么就加入到事务中执行， 如果上下文中不存在事务， 那么就新建事务， 所以这个级别能满足大多数业务场景
* propagation_supports：如果上下文中已经存在事务， 那么久加入到事务中执行， 如果上下文中不存在事务，则使用非事务的方式执行
* propagation_mandatary: 如果上下文中已经存在事务， 那么久加入到事务中执行， 如果上下文中不存在事务，则抛出异常， 比如一段代码不能被单独调用执行，一旦调用则必须有事务包含，否则抛出异常
* propagation_requires_new: 每次都必须new一个新事务， 如果上下文中有事务存在则挂起
* propagation_not_supported: 不支持， 如果上下文中存在事务，则挂起事务， 逻辑执行结束后则恢复事务
* propagation_never: 不能存在， 如果存在抛异常
* propagation_nested: 嵌套事务， 如果上下文中存在事务， 则嵌套执行，如果不存在，新建执行

#### 嵌套事务下如果子事务回滚， 父事务会回滚吗
父事务会回到进入子事务时候的状态，  然后进行其他的逻辑， 进入子事务之前的操作并不会回滚

#### 嵌套事务下如果父事务回滚， 子事务会回滚吗
会的， 子事务是父事务的一部分， 父事务commit之前子事务是不会commit的， 所以子事务会随着父事务一起回滚
